import graph.Annotation;
import graph.Protein;

import java.io.*;
import java.math.BigDecimal;
import java.math.MathContext;
import java.util.*;

import org.apache.commons.math3.util.*;

public class TestingApp {

    /* Path to the file with clusters obtained with the mcl tool */
    /* mcl - https://micans.org/mcl/ */
    private static final String clustersInputFile = "testing/clusters_1.2.txt";
    /* Path to the file with computed p-values */
    private static final String goTermsWithPvaluesFilePath = "testing/go_terms_pvalues_0.6667_threshold.txt";
    /* Format of the file name for p-value results for range of GO annotations */
    private static final String computeCanadaPvaluesFileFormat = "go_terms_%s_%s_pvalues.txt";
    /* Path to the folder, where p-value results for range of GO annotations will be stored */
    private static final String computeCanadaPvaluesOutputFolder = "testing";
    /* Path to the file with results of the analysis */
    private static final String outputPath = "testing/Significant_go_terms_1.2.txt";
    /* Fold change critical value, will be used for proteins filtering */
    // private static final double REMOVAL_THRESHOLD = 0.7;

    /* list of all proteins form the network (proteins should be annotated with the fold change */
    private ArrayList<Protein> proteinsWithFoldChange;
    /* list of all go terms */
    private ArrayList<GoTerm> goTerms;
    /* list of all proteins that were found in clusters generated by mcl */
    private HashSet<String> proteinsInClusters;
    /* count of all proteins in the network */
    private int allProteinsCount;
    /* count of all proteins from the network that are in clusters (generated by mcl) */
    /* and pass the fold change threshold */
    private int successfulProteinsCount;
    /* maps proteins to the fold change */
    private HashMap<String, Double> proteinToFoldChangeMapper;

    double REMOVAL_THRESHOLD;

    /**
     * Creates an instance of TestingApp class.
     *
     * @param proteinsWithFoldChange all proteins from the network, annotated with fold change
     * @param clusters               all go terms, each go term should contain the list of protein names
     */

    public TestingApp(ArrayList<Protein> proteinsWithFoldChange, ArrayList<Annotation> clusters) {
        this.proteinsWithFoldChange = proteinsWithFoldChange;
        this.goTerms = transformGoTerms(clusters);
        this.proteinsInClusters = getProteinsInClusters(clustersInputFile);
        this.proteinToFoldChangeMapper = getProteinFoldChangeMapper(proteinsWithFoldChange);
        this.allProteinsCount = proteinsWithFoldChange.size();
    }

    public void test() {
        this.successfulProteinsCount = getCountOfSuccessfulProteins();
        filterGoTerms();
        annotateGotermsWithPvalues();
        benjaminiHochbergCorrection1();
    }

    /**
     * Counts successful proteins from the network, that are in clusters and pass the threshold.
     *
     * @return count of successful proteins
     */
    private int getCountOfSuccessfulProteins() {
        int passedProteinsCount = 0;
        for (Protein protein : proteinsWithFoldChange) {
            if (proteinsInClusters.contains(protein.getProteinName())) {
                double adjustedFoldChange = proteinToFoldChangeMapper.get(protein.getProteinName()) > 1 ? 1 / proteinToFoldChangeMapper.get(protein.getProteinName()) : proteinToFoldChangeMapper.get(protein.getProteinName());
                if (adjustedFoldChange < REMOVAL_THRESHOLD) {
                    passedProteinsCount += 1;
                }
            }
        }
        return passedProteinsCount;
    }

    /**
     * Modifies GO annotations with successful proteins count.
     */
    private void filterGoTerms() {
        for (GoTerm goTerm : goTerms) {
            int passedProteinsCount = 0;
            for (String protein : goTerm.getProteins()) {
                if (proteinsInClusters.contains(protein)) {
                    proteinsInClusters.add(protein);
                    double adjustedFoldChange = proteinToFoldChangeMapper.get(protein) > 1 ? 1 / proteinToFoldChangeMapper.get(protein) : proteinToFoldChangeMapper.get(protein);
                    if (adjustedFoldChange < REMOVAL_THRESHOLD) {
                        passedProteinsCount++;
                    }
                }
            }
            goTerm.setProteinsPassingFoldChangeCount(passedProteinsCount);
        }
    }

    /**
     * Annotates GO term with computed p-value from file [goTermsWithPvaluesFilePath]
     */
    private void annotateGotermsWithPvalues() {
        HashMap<String, Double> mapper = getGoTermPvalueMapper();
        for (GoTerm goTerm : goTerms) {
            if (mapper.keySet().contains(goTerm.getId())) {
                goTerm.setPvalue(mapper.get(goTerm.getId()));
            }
        }
    }

    /**
     * Gets HashMap, that maps GO annotation ids to p-values.
     *
     * @return HashMap, key: Go term id, value: p-value
     */
    private HashMap<String, Double> getGoTermPvalueMapper() {
        HashMap<String, Double> mapper = new HashMap<>();
        try {
            BufferedReader reader = new BufferedReader(new FileReader(goTermsWithPvaluesFilePath));
            // reader.readLine(); // header
            String line = reader.readLine();
            while (line != null) {
                String goTerm = line.split("\t")[0];
                double pValue = Double.parseDouble(line.split("\t")[1]);
                mapper.put(goTerm, pValue);
                line = reader.readLine();
            }
        } catch (IOException ex) {
            System.out.println("File with p-values was not found");
            ex.printStackTrace();
        }
        return mapper;
    }

    /**
     * Benjamini - hochberg correction implementation
     */
    private void benjaminiHochbergCorrection() {
        Collections.sort(goTerms, (GoTerm o1, GoTerm o2) -> Double.compare(o1.getPvalue(), o2.getPvalue()));
        for (int i = goTerms.size() - 1; i >= 0; i--) {
            double criticalValue = ((i + 1) / (double) goTerms.size()) * 0.05;
            System.out.println(goTerms.get(i).getPvalue() + " " + ((i + 1) / (double) goTerms.size()) * 0.05);
            if (criticalValue > goTerms.get(i).getPvalue()) {
                printGoTerms(outputPath,0, i+1);
                break;
            }
        }
    }

    /**
     * Benjamini - hochberg correction implementation (Rachel's version)
     */
    private void benjaminiHochbergCorrection1() {
        Collections.sort(goTerms, (GoTerm o1, GoTerm o2) -> Double.compare(o1.getPvalue(), o2.getPvalue()));
        GoTerm goTerm = goTerms.get(goTerms.size() - 1);
        goTerm.setAdjustedPvalue(goTerm.getPvalue());
        double previousAdjustedPvalue = goTerm.getPvalue();
        for (int i = goTerms.size() - 2; i >= 0; i--) {
            goTerm = goTerms.get(i);
            double criticalValue = (goTerms.size() / (double) (i + 1)) * (goTerm.getPvalue());
            System.out.println(goTerms.get(i).getPvalue() + " "+((i+1)/(double)goTerms.size())*0.05);
            if (criticalValue > previousAdjustedPvalue) {
                goTerm.setAdjustedPvalue(previousAdjustedPvalue);
            } else {
                goTerm.setAdjustedPvalue(criticalValue);
                previousAdjustedPvalue = criticalValue;
            }
        }

        int i = 0;
        while (i < goTerms.size() && goTerms.get(i).getAdjustedPvalue() < 0.05) {
            i++;
        }
        printGoTerms(outputPath, 0, i+1);
    }

    /**
     * Gets HashMap that maps all proteins to fold change.
     *
     * @param proteins list of proteins in the network
     * @return HashMap, key: Protein name, value: fold change
     */
    private HashMap<String, Double> getProteinFoldChangeMapper(ArrayList<Protein> proteins) {
        HashMap<String, Double> mapper = new HashMap<>();
        for (Protein protein : proteins) {
            mapper.put(protein.getProteinName(), protein.getFoldChange());
        }
        return mapper;
    }

    /**
     * Reads clusters and returns HashSet of all proteins, that are in clusters (size of the cluster should be greater
     * than 1)
     *
     * @param inputFile file with clusters obtained from mcl
     * @return HashSet of all protein names, found in the clusters
     */
    private HashSet<String> getProteinsInClusters(String inputFile) {
        HashSet<String> proteinsInClusters = new HashSet<>();
        try {
            BufferedReader reader = new BufferedReader(new FileReader(inputFile));
            String line = reader.readLine();
            while (line != null) {
                if (line.split("\t").length > 1) {
                    ArrayList<String> clusteredProteins = new ArrayList<>(Arrays.asList(line.split("\t")));
                    proteinsInClusters.addAll(clusteredProteins);
                }
                line = reader.readLine();
            }
            reader.close();
        } catch (IOException ex) {
            System.out.println("File with clusters was not found");
            ex.printStackTrace();
        }
        return proteinsInClusters;
    }

    /**
     * Transforms initial GO annotation format (graph.Cluster) to the format used in this class (GoTerm).
     *
     * @param clusters initial list of GoTerms (graph.Cluster)
     * @return list of GO annotations in new format (GoTerm)
     */
    private ArrayList<GoTerm> transformGoTerms(ArrayList<Annotation> clusters) {
        ArrayList<GoTerm> goTerms = new ArrayList<>();
        for (Annotation cluster : clusters) {
            goTerms.add(new GoTerm(cluster.getName(), cluster.getProtein_symbols()));
        }
        return goTerms;
    }

    /**
     * Prints current state of GO annotations list. Mostly used for result printing.
     *
     * @param outputFile output file path
     */
    private void printGoTerms(String outputFile, int from, int to) {
        try {
            BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));
            writer.write(String.format("%s\t%s\t%s\t%s\t%s\n", "id", "proteins size", "proteins passing fold change size", "pvalue", "adjusted pvalue"));
            for (int i = from; i < to; i++) {
                writer.write(goTerms.get(i).toString() + "\n");
            }
            writer.flush();
            writer.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }


    ///region P-value generation functions
    /* P-values should be computed on ComputeCanada because of the binomial coefficients. This section of code provides
       all functions, needed for p-value calculation for the part of GO annotations. After calculation, the output will
       be stored in the folder. Then you can join all the files together and use it for annotating GoTerms.
     */

    /**
     * Computes p-values for a certain range of GO annotations. Saves obtained output in the folder [computeCanadaPvaluesOutputFolder],
     * format [computeCanadaPvaluesFileFormat].
     *
     * @param from index of 1st go annotation
     * @param to   index of the last go annotation
     */
    public void generatePvalues(int from, int to, double threshold) {
        this.REMOVAL_THRESHOLD = threshold;
        this.successfulProteinsCount = getCountOfSuccessfulProteins();
        filterGoTerms();
        hypergeometricTest(from, to);
        String outputPath = computeCanadaPvaluesOutputFolder + "/" + String.format(computeCanadaPvaluesFileFormat, from, to);
        printGoTermsWithPvalues(outputPath, from, to);
    }

    /**
     * The hypergeometric test uses the hypergeometric distribution to measure the statistical significance of having
     * drawn a sample consisting of a specific number of k successes (out of n total draws) from a population of size
     * N containing K successes. In our case, N is equal to the number of GO annotations [allProteinsCount]; K is number of GO annotations,
     * that are in clusters and pass the fold change threshold [REMOVAL_THRESHOLD] (this number is stored in the variable
     * [successfulProteinsCount]); n is number of all proteins in GO annotation [goTerm.proteins.size()]; k - number of
     * proteins from the GO annotation, which are in clusters and pass the fold change threshold [REMOVAL_THRESHOLD].
     *
     * @param from index of 1st go annotation
     * @param to   index of the last go annotation
     */
    public void hypergeometricTest(int from, int to) {
        for (int i = from; i < to && i < goTerms.size(); i++) {
            GoTerm goTerm = goTerms.get(i);
            double pvalue = computePvalue(goTerm.getProteins().size(), goTerm.getProteinsPassingFoldChangeCount());
            goTerm.setPvalue(pvalue);
        }
    }


    /**
     * Computes the p-value for particular GO annotation. P-value is computed as: probability(N, K, n, k) +
     * + probability(N, K, n, k+1) + ... + probability(N, K, n, n)
     *
     * @param numberOfProteins        number of all proteins in the GO annotation
     * @param numberOfObservedSuccess number of all proteins that are in clusters and pass fold change threshold
     * @return obtained p-value
     */
    private double computePvalue(int numberOfProteins, int numberOfObservedSuccess) {
        double pvalue = 0;
        for (int i = numberOfObservedSuccess; i <= numberOfProteins && i <= successfulProteinsCount; i++) {
            double probability = computeProbability(numberOfProteins, i);
            pvalue += probability;
        }
        return pvalue;
    }

    /**
     * Computes probability of getting [numberOfObservedSuccess] successful proteins in the GO annotation that contains
     * [numberOfProteins] proteins.
     *
     * @param numberOfProteins        number of all proteins in the GO annotation
     * @param numberOfObservedSuccess number of successful proteins (proteins in the clusters and passing fold change
     *                                threshold [REMOVAL_THRESHOLD]
     * @return obtained probability
     */
    private double computeProbability(int numberOfProteins, int numberOfObservedSuccess) {
        BigDecimal dividend1 = getBinomialCoeff(successfulProteinsCount, numberOfObservedSuccess);
        BigDecimal dividend2 = getBinomialCoeff(allProteinsCount - successfulProteinsCount, numberOfProteins - numberOfObservedSuccess);
        BigDecimal divider = getBinomialCoeff(allProteinsCount, numberOfProteins);
        BigDecimal value = dividend1.multiply(dividend2).divide(divider, MathContext.DECIMAL128);
        return Double.parseDouble(value.toString());
    }

    /**
     * Computes binomial coefficient using dynamic programming approach.
     *
     * @return number of ways to choose an (unordered) subset of [k] elements from a fixed set of [n] elements
     */
    private BigDecimal getBinomialCoeff(int n, int k) {
        BigDecimal[][] matrix = new BigDecimal[n + 1][k + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                if (i == 0 || j == 0) {
                    matrix[i][j] = new BigDecimal("1");
                } else {
                    matrix[i][j] = matrix[i - 1][j - 1].add(matrix[i - 1][j]);
                }
            }

        }
        return matrix[n][k];
    }

    /**
     * Outputs range of GoTerms with p-values to the file.
     *
     * @param outputFile output file path
     * @param from       index of 1st go annotation
     * @param to         index of the last go annotation
     */
    public void printGoTermsWithPvalues(String outputFile, int from, int to) {
        try {
            BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile));
            // writer.write(String.format("%s\t%s\n", "id", "pvalue"));
            for (int i = from; i < to && i < goTerms.size(); i++) {
                writer.write(goTerms.get(i).getId() + "\t" + goTerms.get(i).getPvalue() + "\n");
            }
            writer.flush();
            writer.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    //endregion
}

class GoTerm {

    private String id;
    private ArrayList<String> proteins;
    private int proteinsPassingFoldChangeCount;
    private double pvalue;
    private double adjustedPvalue;

    public GoTerm(String id, ArrayList<String> proteins) {
        this.id = id;
        this.proteins = proteins;
        this.proteinsPassingFoldChangeCount = 0;
    }

    public String getId() {
        return id;
    }

    public ArrayList<String> getProteins() {
        return proteins;
    }

    public int getProteinsPassingFoldChangeCount() {
        return proteinsPassingFoldChangeCount;
    }

    public void setProteinsPassingFoldChangeCount(int proteinsPassingFoldChangeCount) {
        this.proteinsPassingFoldChangeCount = proteinsPassingFoldChangeCount;
    }

    public double getPvalue() {
        return pvalue;
    }

    public void setPvalue(double pvalue) {
        this.pvalue = pvalue;
    }

    public double getAdjustedPvalue() {
        return adjustedPvalue;
    }

    public void setAdjustedPvalue(double adjustedPvalue) {
        this.adjustedPvalue = adjustedPvalue;
    }

    @Override
    public String toString() {
        return String.format("%s\t%s\t%s\t%s\t%s", id, proteins.size(), proteinsPassingFoldChangeCount, pvalue, adjustedPvalue);
    }
}


